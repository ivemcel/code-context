

import { MilvusClient, DataType, FunctionType, RRFRanker } from "@zilliz/milvus2-sdk-node";

const address = "http://localhost:19530";
const token = "root:Milvus";
const client = new MilvusClient({address, token});

// Define fields
const fields = [
    {
        name: "id",
        data_type: DataType.Int64,
        is_primary_key: true,
        auto_id: false
    },
    {
        name: "text",
        data_type: DataType.VarChar,
        max_length: 1000,
        enable_match: true,
        enable_analyzer: true
    },
    {
        name: "text_dense",
        data_type: DataType.FloatVector,
        dim: 768
    },
    {
        name: "text_sparse",
        data_type: DataType.SparseFloatVector
    },
    {
        name: "image_dense",
        data_type: DataType.FloatVector,
        dim: 512
    }
];

// define function
const functions = [
    {
      name: "text_bm25_emb",
      description: "text bm25 function",
      type: FunctionType.BM25,
      input_field_names: ["text"],
      output_field_names: ["text_sparse"],
      params: {},
    },
];

const index_params = [{
  field_name: "text_dense",
  index_name: "text_dense_index",
  index_type: "AUTOINDEX",
  metric_type: "IP"
},{
  field_name: "text_sparse",
  index_name: "text_sparse_index",
  index_type: "SPARSE_INVERTED_INDEX",
  metric_type: "BM25",
  params: {
    inverted_index_algo: "DAAT_MAXSCORE", 
  }
},{
  field_name: "image_dense",
  index_name: "image_dense_index",
  index_type: "AUTOINDEX",
  metric_type: "IP"
}];

async function main() {
  try {
    const res = await client.createCollection({
      collection_name: "my_collection",
      fields: fields,
      index_params: index_params,
      functions: functions,
    });
    console.log("Collection created successfully:", res);


    // Helper function to generate random vectors
    const generateVector = (dim: number): number[] => {
      const vector: number[] = [];
      for (let i = 0; i < dim; i++) {
        vector.push(Math.random() * 2 - 1); // Random values between -1 and 1
      }
      return vector;
    };

    // Create sample data with proper vector dimensions
    const data = [
      {
        id: 0, 
        text: "Red cotton t-shirt with round neck", 
        text_dense: generateVector(768),
        // The sparse vector will be generated by the BM25 function
        image_dense: generateVector(512)
      },
      {
        id: 1, 
        text: "Wireless noise-cancelling over-ear headphones", 
        text_dense: generateVector(768),
        image_dense: generateVector(512)
      },
      {
        id: 2, 
        text: "Stainless steel water bottle, 500ml", 
        text_dense: generateVector(768),
        image_dense: generateVector(512)
      }
    ];
    
    const res2 = await client.insert({
      collection_name: "my_collection",
      data: data,
    });
    console.log("Data inserted successfully:", res2);
    
    // Wait for the data to be indexed
    await client.flush({
      collection_names: ["my_collection"],
    });
    console.log("Collection flushed successfully");
    
    // Load the collection to memory
    await client.loadCollection({
      collection_name: "my_collection",
    });
    console.log("Collection loaded successfully");

    // Generate query vectors for testing
    const query_text = "white headphones, quiet and comfortable";
    const query_vector = generateVector(768); // Generate random vector for text_dense
    const query_multimodal_vector = generateVector(512); // Generate random vector for image_dense

    //参数limit 设置为 2 时，每个AnnSearchRequest 会返回 2 个搜索结果。
    // 在本示例中，创建了 3 个AnnSearchRequest 实例，总共产生了 6 个搜索结果。

    const search_param_1 = {
        "data": query_vector, 
        //text_dense 语义文本搜索，允许基于意义而非直接关键词匹配进行上下文理解和检索。
        "anns_field": "text_dense", 
        "param": {"nprobe": 10}, // 探测10个聚类单元
        "limit": 2
    };

    const search_param_2 = {
        "data": query_text, 
        //text_sparse全文搜索或关键词匹配，侧重于文本中精确匹配的单词或短语。
        "anns_field": "text_sparse", 
        "param": {"drop_ratio_search": 0.2}, // 丢弃最低20%的得分项
        "limit": 2
    };


    //要对 ANN 搜索结果集进行合并和重新排序，选择适当的重新排序策略至关重要。Milvus 提供两种重排策略：
    //加权排名：如果结果需要强调某个向量场，请使用该策略。WeightedRanker 可以为某些向量场赋予更大的权重，使其更加突出。
    //RRFRanker（互易排名融合排名器）：在不需要特别强调的情况下选择此策略。RRFRanker 能有效平衡每个向量场的重要性。
    const rerank = RRFRanker(100); // Use number instead of string

    // Perform hybrid search
    const search_res = await client.search({
      collection_name: "my_collection",
      data: [search_param_1, search_param_2],
      limit: 2,
      rerank: rerank
    });
    
    console.log("Search results:", search_res);
    console.log("\nHybrid search demo completed successfully!");
  } catch (error) {
    console.error("Error:", error);
  }
}

main();
